面向过程：根据业务逻辑从上向下写代码,要考虑整个过程。
面向对象（OOP）：将数据与函数绑定到一起，进行封装，这样能够更好的更快速的开发程序，减少了重复代码的重写过程，找一个对象，让其帮你处理问题。
类：类就是创建对象的模板
类的构成：
1.类名
2.类的属性：一组数据及
3.类的方法：允许对进行操作的方法
现实生活中都是现有对象，再有类的，很有道理的

类的定义
class Cat:
    #属性

    #方法
    def eat(self):  #这个地方一定要加self
        print("")

给一个对象添加属性方法为：
对象名.新的属性名=值

获取这个对象的属性，2种方法：
1.对象.属性
2.定义一个方法，这个方法中，使用self.属性

访问方法需要加函数（），访问属性是不需要（），致谢属性的名字

_init_()方法
   1.是python自动调用的方法，调用的时间为：创建完对象之后，立马自动调用
   2.不需要开发者调用，不存在对象名._init_()这种写法
   3.这个方法一般情况会完成一些默认的事情，比如说田间一些属性
   4.  class Xxx：
            def _init_(self,new_a,new_b):
                self.a = new_a
                self.b = new_b
   注意new_a,new_b是局部变量，并不是对象的属性，如果想在_init_方法中添加属性的话，需要使用类似self.属性名=值 的格式，给属性添加就要加self

self是代指创建对象自己的对象本身
一个变量指向了一块空间，然后可以调用方法来给空间，也就是对象添加属性，使用函数操作方法，但是对于函数的调用，并不是在内存中存储
动作函数的代码，而是通过init方法指引对象去自己的类中寻找相同的方法函数

__init__()属于特定功能的方法，而在python中是有很多类似的具有特定功能的函数方法
__str__() 打印对象的时候，会返回对象的地址，但是使用该函数，则返回这个函数下的return值，这个函数还是很有用的，他可以查询该对象的属性信息

数据传递可以使用全局变量
面向对象，封装了数据和方法(函数)

获取、修改属性值：
1.直接通过对象名修改，这个值的风险很大，有可能不符合要求
2.通过方法间接修改 可以通过条件来定义规则

私有属性：
但是为了更好的保存属性安全，即不能随便修改属性，一般处理为
将属性定义为私有属性
添加一个可以调用的方法，供调用

只要属性名前面有2个下划线，那么就表示私有属性
所谓的私有，不能在外部使用 对象名.属性名 获取
但是如果想要在外部进行访问和修改，则设置两个函数，获取和修改属性的函数
保护属性的安全性

而没有添加__的属性则默认是公有属性

note：python中没有java中的public、private等关键字，只能通过是否加下划线来判断
不仅属性是这样，方法也是这样，加__也是私有方法，外部无法访问，但是可以写一个
函数来调用这些私有方法，这样的好处是私有方法不暴露，可以通过在函数中添加判断条件来
调用私有方法，实际开发中，函数就是程序所给的接口

__del__()  当删除一个对象时，会自动调用该方法
python有自动回收垃圾的机制
多个引用指向一个对象的时候，有一个计数器维护着这个对象的内存地址，删除一个应用，则删除一个指向对象的连接，计数器减1，直到计数器减到0的时候
则python的垃圾回收机制会自动的将内存地址回收，此时会调用__del__()
内存泄露：申请多少，释放多少，申请多了，但是释放少了，就泄露了。

#############
继承
一定继承object类 class Cat(Object): =  class Cat:
单继承

父类   基类
父类的子类也无法使用父类的私有属性（__开头的）和私有方法
但当父类的方法不适合子类的时候，就要对父类的方法进行重写

多继承
在python中先继承谁就调用谁的方法，但是如果是多层嵌套，mro算法决定调用哪个父类

多态：定义时的类型和运行时的类型不一样，此时就成为多态
简单点讲：在父类中写了一个方法，在子类中重写了该方法，在调用时，如果传进来的是父类的对象，那么就调用父类的方法，传进来的是子类的对象就是子类的方法，这称之为多态
python是弱类型语言，就是变量的类型是随着所给类型变化的，而在强类型语言中，如果给定了变量的类型在更改对象类型时会报错，而在python中不会
java这种强类型语言的时候在支持多态的时候特别明显，因为类型时早就定义好的，所以在调用方法的时候，就要说明传进来的参数类型，如果是父类的
对象，就调用父类的方法，子类的对象就调用子类的方法，而在函数的申明中，则统一定义为父类的类型，这样子类访问和父类访问均不会出错，
在调用时看传进来的值就行，另外它首先生成一个编译程序，如果类型出错，在编译时就会报错，不像python走一步，执行一步，没有编译的过程，
在Python中多态之所以不明显也是因为这一点，python中没有类型之分，你给什么参数就可以转成什么类型的参数，所以讲在python的函数中
你传进来的参数是什么类型都行。

面向对象： 继承：相同部分，减少重复代码
         封装：类
         多态：定义和调用的对象可能不一样

#############
访问私有对象不可以是因为在访问过程中类中私有变量更改了方法名，在__方法名前面又加上了_Test，即变成了_Test__方法名

类属性是属于类的，并更不跟着对象走，而实力属性就是对象的属性，跟着实例走
如何在程序中访问一个类属性？
1.用对象去访类属性是可以的
2.常用的方法是，使用类去访问类属性
但是如果类属性和实例属性的名字相同时，那么通过对象去取属性时，会获取实例属性的值
类属性和实例属性不同，类属性通过类去访问，设值，实例属性能获取类属性的值，但是更改的属性值只属于对象，而不属于类，所以如果直接删除对象的属性，类属性不受影响

对类属性修改，同样使用类方法，直接取值，并不安全

##########
工厂类
工厂方法
定义了一个创建对象的接口，但有子类决定要实例化的类是哪一个，工厂方法让类的实例化推迟到子类的，抽象的基类提供了一个创建对象的方法
这个思路就是继承，但是继承的是必须重写的方法，在python中叫工厂方法

单例模式
__new__()创建对象函数
单例模式函数

##########
捕获异常  try  catch
try：
   要崩的代码
except：
   处理的方法
一行捕获多个异常,用元组将异常括起来即可。
切想把系统报的异常错误打印出来的花
except (NameError,FileFoundError) as result:
     print("   %s"%result)

捕获所有异常,以下这两种方式都可以，但是后者一定在后面
except Exception as result:
except:
在这后面还可以在接一个else，else后面的语句表示在try部门均无异常就可以执行else语句

try   finally
finally语句表示一定会执行的语句

异常传递
在多层嵌套的函数中，可能存在异常，无论在哪一层发生异常，均可在中间层处理，并且异常发生处类似于return机制，即调用处发生了异常就不会再执行本层函数异常处的代码

自定义异常类
定义的异常类是要继承exception类的，使用raise关键字抛出异常，然后捕捉处理

异常中还可以抛出异常
既可以选择对异常信息进行处理，也可以选择不处理，默认处理，即使用raise

#################
定义一个自己的模块

测试时使用但是当被当成模块导入其他py时不执行使用
if __name__=="__main__":
        print(__name__)
        test()
__name__字段随着调用者不同改变，若是测试则是__main__,若是被调用，则是类名

模块导入
import random就是导入random模块，但是后续引用该模块时，仍然采用random.randint这种引用形式，要加上random这一模块名
但是如果采用from random import *这一导入方法，则不需要引入random这一前缀，直接调用即可
当然只导入部分的话，可以直接写from random import randint，等等，逗号隔开即可

但是模块导入有导入位置的问题
当你导入一个模块，python解析器对模块位置的搜索顺序是：
1.当前目录
2.如果不在当前目录，python则搜索在shell变量pythonpath的每个目录
3.如果都找不到，python会查看默认路径。即bin目录
4.模块搜索路径存储在system变量中。变量里包含当前目录，pythonpath和有安装过程决定的默认目录
import sys
sys.path.append()
sys.path.insert(0,"")

当前你自己创建的模块，直接放在一个文件夹下就行

__pycache__ 该文件就是使用一次程序编译后产生的缓存文件，可能存在于内存中，不需要重复到硬盘中提取文件到内存，更加高效。当原文件改变时，python
编译器会打上一个时间戳，当两者不一样时，会重新编译原文件。

__all__["",""列表里面类或者方法就是from Test import *中*所指的类或者方法

把相关联的类和方法放到一个py文件中，就是模块
如果在文件中加上__init__.py，那么此时这个文件夹就变成一个包，import 包名.文件 ，再后面使用的时候，就是用包名.文件.函数使用即可

如包、模块结构图所示，一般来说先建一个包文件夹，里面放一个__init__()文件，这个文件里面一般写__all__()方法，决定下面哪一个文件可以在form 。。 import *时被导入
在具体的某一个文件里面也会写明__all__()方法，表明在具体的哪一个类或者方法可以被调用
__pycache__则是在包被import之后才会生成的缓存对象
把所写代码分模块肯定是必然的，这是第一，但是如果别人想整体使用你的模块，怎么办，打包整体发布

模块发布
必须要在文件夹中加一个setup.py文件
from distutils.core import setup
setup(name="",version="",description="",author="",py_modules=[,  ,  ,])
最后一个带入子文件
构建模块：python setup.py build
生成不发压缩包: python setup.py sdist  生成和网路下载几乎一样的压缩包文件

下载安装包的安装过程
1.找到模块的压缩包
2.解压
3.即进入文佳佳
4.执行命令 python setup.py install
